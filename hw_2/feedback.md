# 1.

Производная посчитана правильно! Так держать :)

Градиентный спуск тоде правильно!

На самом деле, в функции с градиентным спуском можно было обойтись и без копирования, потому что потом сразу же `curr_w` будет ссылаться уже на другой элемент (после строчки с шагом спуска `curr_w -= lr * grad_f(curr_w)`)


*Вопрос на засыпку*: попали ли мы в глобальный минимум функции? Сколько у функии `f` вообще минимумов и максимумов?

# 2

## 2.1

В `mse` можно сразу посчитать среднее по сумме и не делить вручную - показал в коде. Чисто меньше действий. Это можно сделать, потому что `(y_true - y_pred)**2` - массив размера `n_samples`, и затем мы так же усредняем его.


Не придирка, но обычно можно сгруппировать константы в начале вычисления - это читаемо и иногда добавляет стабильности в вычисления. Показал в коде на примере `mse_grad`. В Данном примере это роли вообще никакой не играет, но к примеру если мы хотим две дроби перемножить к примеру, и просто сначала напишем умножение числителей и потом поделим на произведение знаменателей, то мы можем выйти за границы допустимого числа (**переполнение**). Поэтому бвает лучше расставить скобки:

```{python}
(a/b) * (c/d) # вот так
a / b * c / d # это может взорваться, если число большое получится
```

Если тут что-то непонятно - ничего страшного, просто прочитай потом в свободное время про переполнение. В питоне с этим редко сталкиваешься, но к примеру в с++ - бывает))

Помимо этого к тебе вопросов нет, все супер)

## 2.2

К методу линейной регрессии вопросов нет! Все супер.

## 2.3

Я бы лучше нарисовал гистограммы для признаков, нежели использовал бы pd.describe(). Он показывает только какие-то статистики, а так можно на распределение глянуть.

За плот с корреляцией респект!

# 3

## 3.1

К сигмоиде вопросов нет!

## 3.2

Отличная идея изначально предотвратить взрыв в логарифме!  Но зачем клипать сверху? Это лишнее, у тебя иначе никогда не будет `y_pred=1`. Понятно что он стремится к 1, но ты его клипаешь все равно. Хотя `1e-15` не страшно. 

Можно делать по-другому - можно не клипать `y_pred`, а просто добавлять сразу `eps` в логарифм (показал в коде). Я поставлю доп полбалла за рассмотрение корнер кейса! Good job :)


## 3.3

Класс реализовала - все верно! Только забыла проверить качество модельки - тут можно было использовать метрики из прошлой домашки. А остальное хорошо, но придется снять полбалла.

Причем тут были бы норм метрики - предсказывает то по графику хорошо.

## 3.4

ты видимо после оформления ноутбука оформила иерархию папок и положила данные в отдельную папку, но в коду осталась их прошлая локализация, поэтому `FileNotFoundError`. Недосмотрела - проверяй вседа работу после всех изменений! Особенно в полноценной рабоет это оччень важно! 

Вижу, что дальше не успела сделать работу (у меня в ноутбуке твоем пусто) - очень жаль, потому что по тому куску, который ты сделала - у меня вообще никаких претензий, и я уверен, тут у тебя тоже все получилось бы сделать

Поэтому потом для себя поработай с этим датасетом, мне понравилась твоя работа:)


ИТОГ:

1 - 1/1
2.1 - 2/2
2.2 - 3/3
2.3 - 4/4 + 0.5 (доп за корнер кейс)
3.1 - 0.5/0.5
3.2 - 2.5/2.5
3.3 - 1.5/2
3.4 - 0/5
4 - 0/0.5


СУММА: 14.5 + 0.5 доп = 15 баллов * 0.8 коэфф = 12

Работа у тебя получилась хорошая, жалко, что в конце не успела - я уверен, ты бы затащила тут тоже, там немного оставалось!

Но мне все понравилось, что успела сделать! Комментарии тоже прочти в коде пожалуйста.